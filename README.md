
# my-notes

- ##   **Introduction**

![Hello image ](https://i.ibb.co/4tdndnG/download.png)

 My name is **Maher Joudeh** and I'm a member of the *UI/UX* program.
    I've always had a keen interest in understanding how things work, and I'm excited to be a part of this community.
    It's great to meet you!.

- ## **What I have learned from reading the article:**
    The article talks about fundamental tips every developer should know and what the mindset of the developer should contain to guarantee maximum quality in his work and his well-being.


- ## **The following are the main talking points of the article and a brief description of what I learned from each:**

1. **Conceiving the Purpose of Software** 
The emphasis here is that all software is created to help people and the developer must be aware of this in order to properly mold the software for that purpose.

2. **The Goals of Software Design**
This point further focuses on the principle that the software design should be easy to navigate and manage in order to properly help users and not be a burden on the developer and the user.

3. **(Mis)understanding**
It is important to fully understand your work and what you are doing to achieve the goal of the system and so that we don't cause complexity and the software due to misunderstanding which leads to more misunderstanding and furthermore affects the software.

4. **Simplicity**
Simplicity it's never a bad thing to have in a software making everything simple and easy to comprehend is a big plus because it will have positive feedback on the software and as long as everything works the goal is achieved.

5. **Complexity**
The elaborated in the previous point there is no need to overcomplicate things as long as you understand the goal of the software and its definition, and you work towards achieving them without over complexity because it is crucial to manage and maintain the proper level of complexity.

6. **Maintenance**
the maintenance aspect of developing a software should never be overlooked a good developer must adapt and consider future complications and implementations as it is one of his responsibilities and avoid the idea of quick coding and swift submission without caring about future complications.

7. **Consistency**
keep the basis of your work consistency anything from naming variables to file archiving even to simple code indentations as long as everything is consistent standardized then it is easy to work with whether by you or a future developer.

8. **Prioritizing**
here the article talks about three main elements the desirability, value and effort required for change and it summed up in a simple equation where the desirability it's the value divided by effort this helps the developer prioritize his work properly to avoid overwhelming work pressure.

9. **Solving Problems**
a good developer should know the proper approach to solve problems starting by properly understanding then planning ahead for it and finally segmentation if it's too large to deal with as one entity.

10. **Good enough is fine**
Not everything has to be perfect as long as it does the intended purpose of it, you're a perfectionist dial it down start by achieving the basic requirements of the system then you can proceed to improve and modify if you have the time.

11. **Predictions**
in summary there is no need to protect the future and waste extensive time adapting exactly to what you predict just keep being generic as needed that's it.

12. **Assumptions**
in a nutshell don't overly trust your assumptions when coding just designed for what you know and don't add unnecessary code for what you think you might need or what you think the software might need to perform.

13. **Stop Reinventing**
simply don't reinvent the wheel when you absolutely don't need to.

14. **Resistance**
This follows what we said in the earlier point about prioritization good developers should be resistance to changes unless and they are absolutely needed and add to the purpose of the software.

15. **Automation**
repetitive tasks are never fun, a smart developer should learn how to automate them and move them out of his way.

16. **Code measurement**
An optimal code is a code that achieves the purpose in the least amount of code lines. A longer and more complex code is not always better, especially if it achieves the same goal.

17. **Productivity**
The main rule you should work on is how can I reach my goal fastest way possible.

18. **Testing**
Untested code is basically worthless your code should be locked and handled for errors before delivery.

19. **(Under)Estimation**
Developers aren't the best people at estimations so following previous points mentioned above segment your work so that you can get a better estimation.

20. **Running Away from Rewriting**
Rewriting the code is not always a bad thing sometimes it can be necessary instead of reusing and modifying an old messy incompetent code, but it's most certainly should never be your first thought.

21. **Documentation and Commenting**
A good practice is to always knock comment changes comment on certain procedures and processes done in the code so that you can easily come back to them if you need and keep everything organized and well maintained.

22. **Picking Technologies (Tools, Libraries, etc.)**
Don't overlay depend on technologies gimmicks and tools they can sometimes cause complexity or even delays if there are issues with it.

23. **Self-Development**
don't stay in one place always move forward a small change is better than no change I've been developer should stay up to date with what's going around in the world around him.

24. **Don’t be a hero**
know when to quit and know when to ask for help not everything can be worth approaching.

25. **Don’t Ask Questions… Ask for Help**
Always seek advice and help, don't just ask a simple question waiting for a solution, try to get a second opinion on the problem you're having it will give you a new perspective.

***In summary** these are fundamental points that the writer talks about in order to avoid the pitfalls every developer tends to face.*  
